package lindenmayer;

import java.awt.geom.Point2D;
import java.awt.geom.Point2D.Double;
import java.awt.geom.Rectangle2D;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import java.util.Stack;

/**
 * The class {@link EPSTurtleOptimized} is responsible for creating the
 * PostScript file resulting from applying each {@link Symbol}'s paired action.
 * The Postscript file generated by this class is shorter and uses some special
 * PostScript operators (notably <code>rotate</code>, <code>scale</code>,
 * <code>translate</code>). Unlike {@link EPSTurtle}, this class maintains its
 * angles in degrees and converts them to radians only when new coordinates
 * need be calculated, so as to prevent lossy conversions when using
 * <code>rotate</code>.
 * 
 * @author Philippe Gabriel
 * @version 1.0 2021-mm-dd
 */

public class EPSTurtleOptimized implements Turtle {
    
    private BufferedWriter writer; //BufferedWriter for writing PostScript file
    private StringBuilder content; //Contents of Postscript file to be written
    
    private Rectangle2D boundBox; //Bounding Box necessary for page dimensions
    
    private Point2D coord;    //Point2D indicating turtle's position
    private double orient;    //Double indicating turtle's current orientation
    
    private double unitStep;  //Double holding the set unit step length
    private double unitAngle; //Double indicating set unit angle length
    
    private Stack<State> savedStates; //Stack keeping track of turtle states
    
    public void draw() {
        
        updateLocation();
        
        content.append(unitStep + " 1 scale\n");
        content.append("1.0 0.0 L\n");
        content.append("1.0 0.0 translate\n");
        content.append("1 " + unitStep + " div 1 scale\n");
    }
    
    public void move() {
        
        updateLocation();
        
        content.append(unitStep + " 1 scale\n");
        content.append("1.0 0.0 M\n");
        content.append("1.0 0.0 translate\n");
        content.append("1 " + unitStep + " div 1 scale\n");
    }
    
    public void turnR() {
        
        orient = (orient - unitAngle) % 360;
        
        if (orient < 0) {
        
            orient += 360;
        }
        
        content.append(-unitAngle + " rotate\n");
    }
    
    public void turnL() {
        
        orient = (orient + unitAngle) % 360;
        content.append(unitAngle + " rotate\n");
    }
    
    public void push() {
        
        content.append("0.0 0.0 stroke newpath M\n");
        savedStates.push(new State(coord, orient));
    }
    
    public void pop() {
        
        State prev = savedStates.pop();
        
        content.append("stroke\n");
        
        double distX = prev.position.getX() - coord.getX();
        double distY = prev.position.getY() - coord.getY();
        content.append(-orient + " rotate\n");
        content.append(distX + " " + distY + " translate\n");
        content.append(prev.angle + " rotate\n");
        content.append("0.0 0.0 newpath M\n");
        
        coord = prev.position;
        orient = prev.angle;
    }
    
    public void stay() {
        
        // Does nothing
    }
    
    public void init(Point2D pos, double angle_deg) {
        
        content.append("%!PS-Adobe-3.0 EPSF-3.0\n");
        content.append("%%Title: L-system\n");
        content.append("%%Creator: lindenmayer.EPSTurtleOptimized\n");
        content.append("%%BoundingBox: (atend)\n");
        content.append("%%EndComments\n");
        content.append("/M {moveto} bind def\n");
        content.append("/L {lineto} bind def\n");
        content.append("0.5 setlinewidth\n");
        
        coord = pos;
        orient = angle_deg;
        
        content.append(coord.getX() + " " + coord.getY() + " translate\n");
        content.append("newpath 0.0 0.0 M\n");
        content.append(angle_deg + " rotate\n");
        
        savedStates = new Stack<State>();
    }
    
    public void end() {
        
        content.append("stroke\n");
        content.append("%%Trailer\n");
        content.append("%%BoundingBox: ");
        content.append((int)(boundBox.getMinX()) + " ");
        content.append((int)(boundBox.getMinY()) + " ");
        content.append((int)(boundBox.getMaxX()) + " ");
        content.append((int)(boundBox.getMaxY()) + "\n");
        content.append("%%EOF");
        
        try {
            
            writer.write(content.toString());
            writer.close();
        } catch(IOException e) {
            
            System.err.println("Error accessing file: " + e.getMessage());
            System.exit(0);
        }
    }
    
    public Point2D getPosition() {
        
        return coord;
    }
    
    public double getAngle() {
        
        return orient;
    }
    
    public void setUnits(double step, double delta) {
        
        unitStep = step;
        unitAngle = delta;
    }
    
    /**
     * The setter method {@link #setBoundBox} sets the bounding box rectangle
     * necessary for the dimensions of the final drawing
     *
     * @param box Bounding box with proper position and dimensions
     */
    
    public void setBoundBox(Rectangle2D box) {
        
        boundBox = box;
    }
    
    /**
     * The method {@link createOutput} creates the PostScript file used to
     * write the various the turtle actions to be undertaken.
     *
     * @param path String indicating path of file
     */
    
    public void createOutput(String path) throws IOException {
        
        content = new StringBuilder();
        
        try {
            
            int i = 1;
            File output = new File(path + ".eps");
            
            while (!output.createNewFile()) {
                
                output = new File(path + i++ + ".eps");
            }
            
            writer = new BufferedWriter(new FileWriter(output));
        } catch(IOException e) {
            
            throw new IOException("Unable to access file " + e.getMessage());
        }
    }
    
    /**
     * The method {@link #updateLocation} updates the turtle's location upon
     * the calling of a method which affected its position.
     */
    
    private void updateLocation() {
        
        Point2D distance = new Point2D.Double(
        (unitStep * Math.cos(Math.toRadians(orient))),
        (unitStep * Math.sin(Math.toRadians(orient))));
    
        coord = new Point2D.Double(coord.getX() + distance.getX(), coord.getY() + distance.getY());
    }
    
    /**
     * The class {@link State} defines the fields associated with a turtle's
     * state.
     */
    
    private static class State {
        
        private Point2D position; //Point2D object indicating turtle's position
        private double angle;     //Double indicating turtle's orientation
        
        /**
         * The constructor method {@link State} assigns the position and angle
         * values corresponding to the turtle's current state.
         *
         * @param position Point2D object indicating turtle's position
         * @param angle Double indicating turtle's orientation
         */
         
        private State(Point2D position, double angle) {
            
            this.position = position;
            this.angle = angle;
        }
    }
}